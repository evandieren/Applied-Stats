---
title: "Covid cases in Europe"
author: "Eliott Van Dieren"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(fda)
library(readr)
library(dplyr)
library(ggplot2)
library(tidyverse)
```

# Data manipulations

## Removing countries

```{r}
covid_data <- read_csv("./owid-covid-data.csv")

covid_data <- covid_data %>% filter(continent == 'Europe')

locs <- covid_data %>% group_by(location) %>% summarize(n_na = sum(is.na(total_cases_per_million))/length(total_cases_per_million)) %>% filter(n_na < 0.2) %>% dplyr::select(location) # removing countries with more than 20% NA values

# All countries with less than 5 mil people (because they will have the same weights as ones with 60ish mil people like France for PCA, which does not make sense)
# Also removed Russia and Belarus due to shady reports from the authorities
remove_countries <- c("Albania","Andorra","Bosnia and Herzegovina","Croatia","Cyprus","Estonia","Faeroe Islands","Gibraltar","Guernsey","Iceland","Isle of Man","Jersey","Kosovo","Latvia","Liechtenstein","Lithuania","Luxembourg","Malta","Moldova","Monaco","Montenegro","North Macedonia","San Marino","Slovenia","Vatican","Russia","Belarus")
countries <- locs$location
countries <- countries[!(countries %in% remove_countries)]
n_countries <- length(countries)
data <- covid_data %>% dplyr::select(c('date','location','new_cases_per_million','total_cases_per_million','new_cases_per_million')) %>% filter(location %in% countries)
```

## Finding the starting point and endpoints, and transformations

```{r}
list_df <- list()
start_dates <- rep(as.Date("2000-01-01"),n_countries)
end_date <- as.Date("2020-06-01")
for (i in 1:n_countries){
  data_country <- data[data$location == countries[i],]
  start_dates[i] <- data_country$date[which(data_country$total_cases_per_million > 25)[1]]
  dates <- seq.Date(start_dates[i],end_date,by="day")
  data_country <- data_country[data_country$date %in% dates,]
  plot(dates,data_country$new_cases_per_million,main=countries[i],type="l")
  abline(v=start_dates[i],col="red")
  abline(v=end_date,col="blue")
  delta_time <- as.numeric(end_date-start_dates[i])
  data_country$time <- (0:delta_time)/delta_time
  data_country$total_cases_per_million <- log(data_country$total_cases_per_million)
  colnames(data_country)[4] ="log_total_cases_per_million"
  list_df[[i]] <- data_country
}

df <- do.call("rbind",list_df) #combine all country dataframes into a single one
```


```{r}
# log-plot of cases from start-point to end-point
df %>% group_by(location) %>% 
  ggplot(aes(x = time,  y = log_total_cases_per_million,color = location)) + 
  geom_line() + 
  theme(legend.text = element_text(size=5), legend.key.height= unit(0.2, 'cm'),
        legend.key.width= unit(0.2, 'cm'), legend.title = element_text(size=7))
```

## B-Spline Smoothing

```{r}
df_matrix <- dplyr::select(df,-c("new_cases_per_million","date")) # new cases not needed anymore

smoothing <- function(df,countries) {
  # Computing the smoothing of each row in df using BSplines
  smoothed_list <- list()
  z <- seq(0,1, length=100)
  for (i in 1:length(countries)) {
    df_country <- df[df$location == countries[i],]
    
    weekly_times <- c(seq(0, 1, by = 7/length(df_country$time)),1)
    B <- bsplineS(df_country$time,norder = 6,weekly_times)
    xi_hat <- ginv(t(B) %*% B) %*% t(B) %*% df_country$log_total_cases_per_million
    
    Bplot <- bsplineS(z,norder=6,weekly_times)
    f_hat <- as.vector(Bplot %*% xi_hat)
    smoothed_list[[i]] <- f_hat
  }
  return(mat <- do.call(rbind, smoothed_list))
}

df_matrix <- smoothing(df_matrix,countries)

matplot(t(df_matrix),type="l")
```

## PCAAAA

```{r}
z <- seq(1,100)
perform_pca <- function(X,z){
  mu <- colMeans(X) # We substract the mean from X (see slides)
  X <- sweep(X,2,mu)
  
  SVD <- svd(X) # we compute X = UDV^T
  Scores <- SVD$u %*% diag(SVD$d) # computing (z_{n,j}) = UD 
  Loadings <- SVD$v # Eigenvectors

  FVE <- SVD$d^2/sum(SVD$d^2) # Fraction of variance explained

  lam <- sqrt(length(z)) # measure change
  
  # Plotting
  op <- par(mfrow=c(3,2),mar=rep(2,4))
  plot(z, X[1,]+mu,type="l", ylim=range(X+mu), main="Data and the mean")
  for(n in 1:dim(X)[1]) points(z, X[n,]+mu,type="l")
  points(z,mu,col=2,lwd=2,type="l")
  plot(Scores[1,]*sign(sum(Loadings[,1])), Scores[2,]*sign(sum(Loadings[,2])), main="1st vs 2nd PC scores")
  
  plot(z,Loadings[,1]*sign(sum(Loadings[,1])),type="l", main=paste0("1st PC (",round(100*FVE[1])," % of var)"))
  # plot(z, X[1,]+mu,type="l", ylim=range(X+mu))
  # for(n in 1:dim(X)[1]) points(z, X[n,]+mu,type="l")
  # points(z,mu,col=2,lwd=2,type="l")
  # points(z,mu+3*SVD$d[1]/lam*SVD$v[,1],col=2,lwd=2,type="l",lty=2)
  # points(z,mu-3*SVD$d[1]/lam*SVD$v[,1],col=2,lwd=2,type="l",lty=2)
  
  plot(z,Loadings[,2]*sign(sum(Loadings[,2])),type="l", main=paste0("2nd PC (",round(100*FVE[2])," % of var)"))
  # plot(z, X[1,]+mu,type="l", ylim=range(X+mu))
  # for(n in 1:dim(X)[1]) points(z, X[n,]+mu,type="l")
  # points(z,mu,col=2,lwd=2,type="l")
  # points(z,mu+10*SVD$d[2]/lam*SVD$v[,2],col=2,lwd=2,type="l",lty=2)
  # points(z,mu-10*SVD$d[2]/lam*SVD$v[,2],col=2,lwd=2,type="l",lty=2)
  
  plot(z,Loadings[,3]*sign(sum(Loadings[,3])),type="l", main=paste0("3rd PC (",round(100*FVE[3])," % of var)"))
  # plot(z, X[1,]+mu,type="l", ylim=range(X+mu))
  # for(n in 1:dim(X)[1]) points(z, X[n,]+mu,type="l")
  # points(z,mu,col=2,lwd=2,type="l")
  # points(z,mu+30*SVD$d[3]/lam*SVD$v[,3],col=2,lwd=2,type="l",lty=2)
  # points(z,mu-30*SVD$d[3]/lam*SVD$v[,3],col=2,lwd=2,type="l",lty=2)
  
  plot(z,Loadings[,4]*sign(sum(Loadings[,4])),type="l", main=paste0("4th PC (",round(100*FVE[4])," % of var)"))
  # plot(z, X[1,]+mu,type="l", ylim=range(X+mu))
  # for(n in 1:dim(X)[1]) points(z, X[n,]+mu,type="l")
  # points(z,mu,col=2,lwd=2,type="l")
  # points(z,mu+30*SVD$d[4]/lam*SVD$v[,4],col=2,lwd=2,type="l",lty=2)
  # points(z,mu-30*SVD$d[4]/lam*SVD$v[,4],col=2,lwd=2,type="l",lty=2)
}
perform_pca(df_matrix,z)
```

## Second order derivs
```{r}

diff_df <- t(diff(t(df_matrix)))/df_matrix[,1:(length(df_matrix[1,])-1)]

diff_df <-t(diff(t(df_matrix)))

#matplot(t(diff_df),type="l")

est_diff <- diff_df[1,]
plot(1:length(est_diff),est_diff,type="l")

plot(df_matrix[1,],type="l")
lines(df[df$location=="Austria",]$log_total_cases_per_million)

country_df <- df[df$location=="Austria",]$log_total_cases_per_million
real_diff <- diff(country_df)/country_df[1:(length(country_df)-1)]

plot(real_diff,type="l")
lines(1:length(est_diff),est_diff,type="l",col="red")

#plot(df[df$location=="Austria",]$new_cases_per_million,type="l")
#plot(df[df$location=="Austria",]$log_total_cases_per_million,type="l")

plot(1:length(df[df$location == "Austria",]$new_cases_per_million),df[df$location == "Austria",]$new_cases_per_million,type="l")

perform_pca(diff_df,z[2:length(z)])
```